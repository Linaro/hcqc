# HCQC - HPC compiler quality checker

## Introduction

HCQC is a tool for investigating the quality of code generation of the kernel part of the HPC application by the compiler.

Many HPC applications have a few hot spots which are a very narrow range of code, consisting of one function or several consecutive loops.
These hot spots occupy most of the program execution time.
Therefore, the quality of the code of the hot spot is important for performance.

???

HCQC is a tool to help improve the performance of hot spots.

## Quickstart Guide

HCQC currently mainly deals with GCC or Clang/LLVM on Linux of 64 bit ARM architecture(AArch64).
For other architectures, see [How to add new architectures](#HOWARCH).

In the following, `${INSTALL_DIRECTORY}` shows the directory where hcqc exists.

### Installation

To execute HCQC, it is necessary to define a compiler and command line options for the compiler to be investigated.
The definition of the investigation target is described in the configuration file of JSON format placed in directory `${INSTALL_DIRECTORY}/hcqc/config`.
For example, if you want to investigate the optimization level `-O2` of the GCC whose version is 7.1.1, whose absolute path is `/usr/bin/gcc`, then the configuration file should be written as follows:

    {
        "DISTRIBUTION" : "OpenSUSE Tumbleweed",
        "ARCH" : "aarch64",
        "CPU" : "AMD Opteron A1100 Cortex A57",
        "LANGUAGE" : "C",
        "COMPILER" : "GCC",
        "COMMAND" : "/usr/bin/gcc",
        "VERSION" : "7.1.1",
        "OPT_FLAGS" : ["-O2"],
        "ASM_FLAGS" : ["-S", "-fverbose-asm"],
        "FLAG_DB" : [["?DEBUG_FLAG", "-g"],
                     ["?C99_STANDARD", "-std=c99"]]
    }

Explanation of each field of the configuration file is described in [How to create new configuration files](#HOWCONFIG).

The name of the configuration file including this definition is `gcc-config.json` in the following.

### Running samples

To investigate the quality of the defined configuration, it is necessary to compile and execute test programs and collect data using the configuration file.
All test programs exist under directory `${INSTALL_DIRECTORY}/hcqc/test-program`.
In the following description, it is assumed that `sample` test program is used as a test program.
To investigate the quality of the compiler, it is necessary to specify a metric indicating the type of data collection.

In this case, the metric criteria `kind` for taking statistics of the mnemonic type, which is included in the function which includes hot spots, is used as an example.
Regarding the configuration file `gcc-config.json`, to collect data of the measurement standard `kind` from the test program `sample`, execute the following command:

    % cd ${INSTALL_DIRECTORY}/hcqc
    % ./command/hcqc gcc-config sample kind

By executing this command, the following processing is executed.

(1) Using the compiler and compile options specified in the configuration file, compile and execute the test program `sample` and confirm that the execution result is correct.

All the files generated by this work are placed under the following directory:

    ${INSTALL_DIRECTORY}/hcqc/work/sample/gcc-config/kind

(2) From the assembly code generated by compiling the kernel part of the test program `sample`,
    a control flow graph of the kernel part is created.
    Based on the control flow graph, a result file `gcc-config--sample--kind.json` which is statistical data of the mnemonic based on the measurement standard `kind` is created.

The content of the result file `gcc-config--sample--kind.json` is, for example, as follows:

    [
        [ "TITLE", ["CFG", "DEPTH", "memory", "branch", "other"]],
        [ "kernel cond .L1", [ "0", "0", "1", "1"]],
        [ "               ", [ "0", "0", "0", "7"]],
        [ ".L5            ", [ "1", "0", "0", "1"]],
        [ ".L4            ", [ "2", "1", "0", "3"]],
        [ ".L3    cond .L3", [ "3", "3", "1", "4"]],
        [ "       cond .L4", [ "2", "0", "1", "2"]],
        [ "       cond .L5", [ "1", "0", "1", "5"]],
        [ ".L1         end", [ "0", "0", "1", "0"]],
        [ "*SUMMARY*", [ "-", "4", "5", "23"]]]

All the result files generated using the test program `sample` are placed under the following directory:

    ${INSTALL_DIRECTORY}/hcqc/result/sample

### Viewing results

The execution result of command `./command/hcqc` is data in JSON format.
To make them easier to see, use the command `./command/hcqc-report`.
For example, the following command:

    % ./command/hcqc-report gcc-config sample R0 kind

creates a report file `gcc-config--sample--R0.csv` with CSV format in the following directory:

    ${INSTALL_DIRECTORY}/hcqc/report/sample
    
The contents of the report file are as follows, for example:

    CFG,DEPTH,memory,branch,other
    kernel cond .L1,0,0,1,1
                   ,0,0,0,7
    .L5            ,1,0,0,1
    .L4            ,2,1,0,3
    .L3    cond .L3,3,3,1,4
           cond .L4,2,0,1,2
           cond .L5,1,0,1,5
    .L1         end,0,0,1,0
    *SUMMARY*,-,4,5,23

### Cleaning up

By executing the following command, all generated files under `work` or `report` directories except the result data files under `result` directory can be deleted.

    % cd ${INSTALL_DIRECTORY}/hcqc
    % ./clean-all.sh

To delete all the generated files including the result data files under `result` directory, 
Execute the following command:

    % cd ${INSTALL_DIRECTORY}/hcqc
    % ./realclean-all.sh

## Workflow of HCQC

### Confirmation of execution of test programs

The HCQC acquires the test program data on the specified configuration file in the following procedure.
In the following, when using the configuration file

    ${INSTALL_DIRECTORY}/hcqc/config/CONFIG.json

the test program

    ${INSTALL_DIRECTORY}/hcqc/test-program/sample

and the metric program name `kind`, he execution of HCQC is as followsï¼š

    % cd ${INSTALL_DIRECTORY}/hcqc
    % ./command/hcqc CONFIG sample kind

The workflow executing this command is as follows:

First, hcqc opens the configuration file

    ${INSTALL_DIRECTORY}/hcqc/config/CONFIG.json

and reads each field of the JSON format file.
The configuration file defines the compiler to be investigated and optimization options, and includes, for example, the following contents:

    {
        "DISTRIBUTION" : "OpenSUSE Tumbleweed",
        "ARCH" : "aarch64",
        "CPU" : "AMD Opteron A1100 Cortex A57",
        "LANGUAGE" : "C",
        "COMPILER" : "GCC",
        "COMMAND" : "/usr/bin/gcc",
        "VERSION" : "7.1.1",
        "OPT_FLAGS" : ["-O2"],
        "ASM_FLAGS" : ["-S", "-fverbose-asm"],
        "FLAG_DB" : [["?DEBUG_FLAG", "-g"],
    		 ["?C99_STANDARD", "-std=c99"]]
    }
    
The meaning of each field of the configuration file is as follows:

    "DISTRIBUTION" : distribution of OS(Currently unused)
    "ARCH" : the machine hardware name(Must match `uname -m`)
    "CPU" : the CPU name(Currently unused)
    "LANGUAGE" : target programming language(Must match `LANGUAGE` of test programs)
    "COMPILER" : the name of compiler
    "COMMAND" : full path name of the compiler command
    "VERSION" : the compiler version number(Must match `--version` result)
    "OPT_FLAGS" : compiler options to be investigated
    "ASM_FLAGS" : compiler options for generating assembly code
    "FLAG_DB" : definition of flag variables used in program information file

From the field information of `FLAG_DB`, HCQC creates a flag replacement map.
For example, the definition of the field of FLAG_DB:

    "FLAG_DB" : [["?DEBUG_FLAG", "-g"],
                 ["?C99_STANDARD", "-std=c99"]]

generates the map:

    { "?DEBUG_FLAG" : "-g",
      "?C99_STANDARD" : "-std=c99" }

Next, the program information file

    ${INSTALL_DIRECTORY}/hcqc/test-program/sample/program-info.json

for the specified test program `sample` is opened and each field of the JSON format file is read.
The program information file includes information for compiling and executing the test program.
The contents are, for example, as follows:

    {
        "LANGUAGE" : "C",
        "MAIN_FLAGS" : ["?DEBUG_FLAG", "?C99_STANDARD"],
        "KERNEL_FLAGS" : ["-DFAST", "?C99_STANDARD"],
        "LINK_FLAGS" : ["?C99_STANDARD"],
        "LIB_LIST" : ["-lm"],
        "MAIN_FILENAME" : "main.c",
        "KERNEL_FILENAME" : "kernel.c",
        "KERNEL_FUNCTION_NAME" : "kernel",
        "INPUT" : [ "STDIN", "in.data" ],
        "OUTPUT" : [ "STDOUT", "out.data" ]
    }

The meaning of each field is as follows:

    "LANGUAGE" : programming language describing the test program
    "MAIN_FLAGS" : compile options for compiling files in the main part
    "KERNEL_FLAGS" : compile options for compiling files in the kernel part
    "LINK_FLAGS" : link options for generating executable files
    "LIB_LIST" : library specification options used to generate executable file
    "MAIN_FILENAME" : the file name of the main part
    "KERNEL_FILENAME" : the file name of the kernel part
    "KERNEL_FUNCTION_NAME" : the name of kernel function
    "INPUT" : specification of input data of executable file
    "OUTPUT" : specification of output data of executable file

Using these pieces of information, HCQC compiles and executes the test program, and verifies the result.
First, it compiles the main file and generates the object file.
At this time, HCQC uses the compiler which is specified in the COMMAND field of the configuration file.
That is, the command to compile the file of the main part has the following form:

    % COMMAND MAIN_FILENAME MAIN_FLAGS -c -o RESULT_FILENME

Here, `RESULT_FILENME` is the file name obtained by converting the suffix of `MAIN_FILENAME` into `.o`.
At this time, the flag variable in `MAIN_FLAGS` is replaced by using the `FLAG_DB` information in the configuration file.
The command actually executed is, for example, as follows:

    % /usr/bin/gcc ${INSTALL_DIRECTORY}/hcqc/test-program/sample/main.c \
      -g -std=c99 -c -o ${INSTALL_DIRECTORY}/hcqc/work/sample/CONFIG/kind/main.o
      
Similarly, HCQC compiles the file of the kernel part with the following command:

    % COMMAND KERNEL_FILENAME KERNEL_FLAGS OPT_FLAGS -c -o RESULT_FILENME
    
At this time, the command actually executed is, for example, as follows:

    % /usr/bin/gcc ${INSTALL_DIRECTORY}/hcqc/test-program/sample/kernel.c
      -DFAST -std=c99 -O2 -c -o ${INSTALL_DIRECTORY}/hcqc/work/sample/CONFIG/kind/kernel.o

HCQC executes the following command to create an executable file from generated object files:

    % COMMAND LINK_FLAGS RESULT_FILENAME_LIST -o EXEC_FILENAME LIB_LIST

At this time, the command actually executed is, for example, as follows:

    % /usr/bin/gcc -std=c99 ${INSTALL_DIRECTORY}/hcqc/work/sample/CONFIG/kind/main.o
      ${INSTALL_DIRECTORY}/hcqc/work/sample/CONFIG/kind/kernel.o
       -o ${INSTALL_DIRECTORY}/hcqc/work/sample/CONFIG/kind/a.out -lm

Next, HCQC executes the created executable file with the specified input data and verifies the result.
In the sample program information file, the specification of the input data is as follows:

    "INPUT" : [ "STDIN", "in.data" ]

This means that HCQC executes the program by inputting the data of the file `in.data` to the standard input.
In the sample program information file, the specification of the output data is as follows:

    "OUTPUT" : [ "STDOUT", "out.data" ]
    
This means that HCQC verifies the execution result by comparing the result of the standard output with the content of the file out.data.
At this time, the command actually executed is, for example, as follows:

     % ${INSTALL_DIRECTORY}/hcqc/work/sample/CONFIG/kind/a.out
       < in.data
       > ${INSTALL_DIRECTORY}/hcqc/work/sample/CONFIG/kind/out.data
     % /usr/bin/diff 
       ${INSTALL_DIRECTORY}/hcqc/work/sample/CONFIG/kind/out.data
       ${INSTALL_DIRECTORY}/hcqc/test-program/sample/out.data
       
After confirming that the execution result is correct, HCQC executes the metric program and obtain data about the test program.
For this purpose, HCQC generates an assembly code file of the kernel part of the test program.
To do this, HCQC executes the next command which changed part of the command to compile the kernel part.

    % COMMAND KERNEL_FILENAME KERNEL_FLAGS OPT_FLAGS ASM_FLAGS -o ASM_FILENAME

At this time, the command actually executed is, for example, as follows:

    % /usr/bin/gcc ${INSTALL_DIRECTORY}/hcqc/test-program/sample/kernel.c
      -DFAST -std=c99 -O2 -S -fverbose-asm
      -o ${INSTALL_DIRECTORY}/hcqc/work/sample/CONFIG/kind/kernel.s

### Executing metric programs

When execution of the test program is confirmed, HCQC executes the metric program.
When the metric program name is M, HCQC executes the set of scripts

    ${INSTALL_DIRECTORY}/hcqc/command/metric/M/M000.py
    ${INSTALL_DIRECTORY}/hcqc/command/metric/M/M001.py
    ....
    ${INSTALL_DIRECTORY}/hcqc/command/metric/M/M999.py

under directory

    ${INSTALL_DIRECTORY}/hcqc/command/metric/M

in order.
HCQC uses the field information read from the configuration file, evaluates the `match_p` method in each script, and executes a script whose result is True.
If the evaluation result of the `match_p` method is False, HCQC stops executing the script and tries the next script.

The method of acquiring metric information from the target test program differs depending on the target architecture and compiler.
Therefore, it is necessary to select a script suitable for the specified configuration file and test program.

The example execution command is as follows:

    % ./command/hcqc CONFIG sample kind

then the metric program name is `kind`.
Therefore, HCQC executes the script that exists under the directory

    ${INSTALL_DIRECTORY}/hcqc/command/metric/kind
    
This directory has only the following script file:

  ${INSTALL_DIRECTORY}/hcqc/command/metric/kind/kind999.py

and, HCQC executes this script.

Generally, each metric program performs the following operations.

(1) Create a control flow graph from the generated assembly code file.

In this example, a control flow graph is created from the file

    ${INSTALL_DIRECTORY}/hcqc/work/sample/CONFIG/kind/kernel.s

and a file

    ${INSTALL_DIRECTORY}/hcqc/work/sample/CONFIG/kind/kernel.s.dot

which represents the control flow graph is created.
The information of this control flow graph corresponds to the following part of the result information file.

    [ "TITLE", ["CFG", "DEPTH"
    [ "kernel cond .L1", [ "0",
    [ "               ", [ "0",
    [ ".L5            ", [ "1",
    [ ".L4            ", [ "2",
    [ ".L3    cond .L3", [ "3",
    [ "       cond .L4", [ "2",
    [ "       cond .L5", [ "1",
    [ ".L1         end", [ "0",

It corresponds to the first and second column parts of the csv file of the result report file.

    CFG,DEPTH
    kernel cond .L1,0
                   ,0
    .L5            ,1
    .L4            ,2
    .L3    cond .L3,3
           cond .L4,2
           cond .L5,1
    .L1         end,0

Here, the column of CFG represents the control flow graph, and the column of DEPTH represents the depth of nesting of the loop (0 outside the loop).
Each row of the CFG column corresponds to each basic block of the control flow graph.
Here, `cond` means that the basic block ends with a conditional branch instruction having a fallthrough, and `goto` means that the basic block ends with an unconditional branch instruction.
Also, `end` means the end of the function.

(2) Information unique to the metric program is collected and output as information of additional columns to the result file.

For example, the metric program `kind` classifies the mnemonic contained in each basic block of the control flow graph into a memory access instruction (memory), a branch instruction (branch), and others (other).
In this example, `kind` generates the following part of the result information file.

    "memory", "branch", "other"]],
    "0", "1", "1"]],
    "0", "0", "7"]],
    "0", "0", "1"]],
    "1", "0", "3"]],
    "3", "1", "4"]],
    "0", "1", "2"]],
    "0", "1", "5"]],
    "0", "1", "0"]],
    "4", "5", "23"]]]
    
This information corresponds to the following part of the result report file.

    memory,branch,other
    0,1,1
    0,0,7
    0,0,1
    1,0,3
    3,1,4
    0,1,2
    0,1,5
    0,1,0
    4,5,23

Information gathered by the metric program is saved in the result file under the directory

    ${INSTALL_DIRECTORY}/hcqc/result/sample

if the test program name is `sample`.
In that case, the file name becomes:

    "configuration file name"--"test program name"--"metric program name".json

In this example, the file name is as follows:
    
    ${INSTALL_DIRECTORY}/hcqc/result/sample/CONFIG--sample--kind.json

`Clean` processing does not delete the file under `result`.
Therefore, if the same configuration file, test program, and metric program are specified and executed for the second time and thereafter:

    % ./command/hcqc CONFIG sample kind

At this time, the file name of the result to be created is:

    ${INSTALL_DIRECTORY}/hcqc/result/sample/CONFIG--sample--kind.json.new

first.
And HCQC compares the following two files.

    ${INSTALL_DIRECTORY}/hcqc/result/sample/CONFIG--sample--kind.json
    ${INSTALL_DIRECTORY}/hcqc/result/sample/CONFIG--sample--kind.json.new
    
If the contents of these two files are the same, delete the new file (.new).
If the contents of these two files are different, rename the old file to the file name with the current time appended to the old file, for example

    ${INSTALL_DIRECTORY}/hcqc/result/sample/CONFIG--sample--kind.json--2017-10-12-13-26-13

and delete the suffix `.new` from the name of the new file.
That is, as a result, the following two files remain.

    ${INSTALL_DIRECTORY}/hcqc/result/sample/CONFIG--sample--kind.json
    ${INSTALL_DIRECTORY}/hcqc/result/sample/CONFIG--sample--kind.json--2017-10-12-13-26-13

### Creating report files

????????????????????

## The role of the metric program

### Status of each metric program

| arch | compiler | op | kind | regalloc | ilp | swpl | vectorize |
|---|---|---|---|---|---|---|---|
|AArch64 | GCC | Y | Y | Y | N | N | N |
|AArch64 | Clang/LLVM | Y | Y | Y | N | N | N |
|x86_64 | GCC | Y | N | N | N | N | N |
|x86_64 | Clang/LLVM | Y | N | Y | N | N | N |

### op

???

### kind

???

### regalloc

???

## <a name="HOWCONFIG"> How to create new configuration files 

 ???

## How to add new test programs

 ???

## How to add new metric programs

 ???

## <a name="HOWARCH">How to add new architectures

 ???

## Known Bugs

Currently, HCQC cannot handle the assembly code with table branches and function calls by function pointers.

## Future Work

 ???
